"""Safe Expression Executor for LLM-generated search strategies.

Provides a restricted eval() environment for executing Python expressions
generated by the LLM in Phase 1 (search_strategy).
"""

import logging
from typing import Any, Dict, Optional

logger = logging.getLogger(__name__)


class SafeExpressionExecutor:
    """Execute LLM-generated Python expressions safely.

    Provides a restricted namespace with only allowed builtins and
    safe operations for evaluating search strategy expressions.

    Examples:
        >>> executor = SafeExpressionExecutor()
        >>> context = {"score": 5, "remaining": 10}
        >>> executor.execute("score >= 8 or remaining == 0", context)
        False
        >>> executor.execute_bool("score >= 4", context)
        True
    """

    ALLOWED_BUILTINS = {
        # Type constructors
        "int",
        "float",
        "str",
        "bool",
        "list",
        "dict",
        # Constants
        "True",
        "False",
        "None",
        # Aggregate functions
        "len",
        "sum",
        "min",
        "max",
        "abs",
        "round",
        # Iterators/predicates
        "any",
        "all",
        "sorted",
        "reversed",
        "enumerate",
        "zip",
        "range",
        # Membership testing
        "isinstance",
    }

    def __init__(self):
        """Initialize executor with safe builtins namespace."""
        # Build restricted builtins dict
        import builtins

        self._safe_builtins = {}
        for name in self.ALLOWED_BUILTINS:
            if hasattr(builtins, name):
                self._safe_builtins[name] = getattr(builtins, name)

    def execute(self, expr: str, context: Dict[str, Any]) -> Any:
        """Execute expression with given context variables.

        Args:
            expr: Python expression string
            context: Dict of variable names to values available in expression

        Returns:
            Expression result, or None if execution fails
        """
        if not expr or not isinstance(expr, str):
            return None

        try:
            # Create restricted globals with only safe builtins
            safe_globals = {"__builtins__": self._safe_builtins}

            # Execute in restricted namespace
            result = eval(expr, safe_globals, context)
            return result
        except Exception as e:
            logger.debug(f"Expression execution failed: {expr!r} -> {e}")
            return None

    def execute_bool(
        self,
        expr: str,
        context: Dict[str, Any],
        default: bool = False,
    ) -> bool:
        """Execute expression expecting boolean result.

        Args:
            expr: Python expression string
            context: Dict of variable names to values
            default: Default value if execution fails or result is None

        Returns:
            Boolean result of expression, or default on failure
        """
        result = self.execute(expr, context)
        if result is None:
            return default
        try:
            return bool(result)
        except (TypeError, ValueError):
            return default

    def execute_float(
        self,
        expr: str,
        context: Dict[str, Any],
        default: float = 0.0,
    ) -> float:
        """Execute expression expecting numeric result.

        Args:
            expr: Python expression string
            context: Dict of variable names to values
            default: Default value if execution fails or result is None

        Returns:
            Float result of expression, or default on failure
        """
        result = self.execute(expr, context)
        if result is None:
            return default
        try:
            return float(result)
        except (TypeError, ValueError):
            return default

    def execute_str(
        self,
        expr: str,
        context: Dict[str, Any],
        default: Optional[str] = None,
    ) -> Optional[str]:
        """Execute expression expecting string result.

        Args:
            expr: Python expression string
            context: Dict of variable names to values
            default: Default value if execution fails or result is None

        Returns:
            String result of expression, or default on failure
        """
        result = self.execute(expr, context)
        if result is None:
            return default
        if isinstance(result, str):
            return result
        try:
            return str(result)
        except (TypeError, ValueError):
            return default

    def validate_expression(self, expr: str) -> bool:
        """Validate that an expression is syntactically correct.

        Args:
            expr: Python expression string

        Returns:
            True if expression compiles without error
        """
        if not expr or not isinstance(expr, str):
            return False

        try:
            compile(expr, "<string>", "eval")
            return True
        except SyntaxError:
            return False
