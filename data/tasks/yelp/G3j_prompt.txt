============================================================
Agenda
============================================================

Help assess time efficiency and wait times at this restaurant.

Analyze each review to identify mentions of waiting, timing, and pacing.
For each record, extract the L0 primitives defined below.

This task adds L1.5 time-phase grouping to identify where delays occur.

============================================================
L0: Primitives (per-review extraction)
============================================================

WAIT_FOR_TABLE
- none: seated immediately or very quickly
- short: reasonable wait (under 15 min)
- moderate: noticeable wait (15-30 min)
- long: significant wait (30-60 min)
- excessive: very long wait (60+ min)
- not_mentioned: wait time not discussed

RESERVATION_ACCURACY
- honored: reservation honored on time
- slight_delay: 5-10 min past reservation time
- significant_delay: 15+ min past reservation time
- lost: reservation lost or not honored
- not_applicable: no reservation made
- not_mentioned: not discussed

FOOD_DELIVERY_SPEED
- fast: food arrived quickly
- reasonable: normal timing
- slow: took longer than expected
- very_slow: excessive wait for food
- not_mentioned: not discussed

SERVICE_PACING
- perfect: well-paced, not rushed or dragging
- slightly_rushed: felt a bit hurried
- very_rushed: pushed to leave quickly
- too_slow: service dragged between courses
- forgotten: felt forgotten by staff
- not_mentioned: not discussed

CHECKOUT_SPEED
- fast: quick check and payment
- reasonable: normal checkout time
- slow: waited too long for check
- not_mentioned: not discussed

OVERALL_TIME_SENTIMENT
- efficient: praised for speed/efficiency
- acceptable: timing was fine
- frustrating: timing issues noted
- unacceptable: timing ruined experience
- not_mentioned: not discussed

============================================================
L1: Composites (derived per review)
============================================================

GOOD_TIME_EXPERIENCE = true iff ANY:
  - OVERALL_TIME_SENTIMENT in {efficient, acceptable}
  - WAIT_FOR_TABLE in {none, short} AND FOOD_DELIVERY_SPEED in {fast, reasonable}
Else GOOD_TIME_EXPERIENCE = false

BAD_TIME_EXPERIENCE = true iff ANY:
  - OVERALL_TIME_SENTIMENT in {frustrating, unacceptable}
  - WAIT_FOR_TABLE in {long, excessive}
  - FOOD_DELIVERY_SPEED = very_slow
Else BAD_TIME_EXPERIENCE = false

============================================================
L1.5: Time Phase Grouping
============================================================

Group reviews by time phase where issues occurred:
  ARRIVAL = wait_for_table, reservation issues (getting seated)
  DURING_MEAL = food_delivery_speed, service_pacing (during dining)
  DEPARTURE = checkout_speed (leaving)

For each phase bucket, compute:
  BUCKET_N_REVIEWS = count of reviews mentioning this phase
  BUCKET_N_GOOD = count with good experience in this phase
  BUCKET_N_BAD = count with bad experience in this phase
  BUCKET_EFFICIENCY_RATE = BUCKET_N_GOOD / max(BUCKET_N_GOOD + BUCKET_N_BAD, 1)

Time Pattern Analysis:
  WORST_PHASE = bucket with lowest EFFICIENCY_RATE (if any issues)
  BEST_PHASE = bucket with highest EFFICIENCY_RATE
  N_PHASES_EFFICIENT = count of buckets where EFFICIENCY_RATE >= 0.7

  TIME_PATTERN:
    if N_PHASES_EFFICIENT >= 3: "consistently_efficient"
    elif ARRIVAL bucket EFFICIENCY_RATE < 0.5: "seating_bottleneck"
    elif DURING_MEAL bucket EFFICIENCY_RATE < 0.5: "kitchen_slow"
    elif DEPARTURE bucket EFFICIENCY_RATE < 0.5: "checkout_issues"
    elif N_PHASES_EFFICIENT >= 1: "phase_dependent"
    else: "overall_slow"

============================================================
L2: Aggregates (restaurant-level)
============================================================

Constants:
  BASE_SCORE = 5.0

Counts:
  N_TIME_REVIEWS = count of reviews with any time-related primitives mentioned
  N_GOOD = count where GOOD_TIME_EXPERIENCE = true
  N_BAD = count where BAD_TIME_EXPERIENCE = true

Confidence Level:
  if N_TIME_REVIEWS == 0: none
  elif N_TIME_REVIEWS <= 2: low
  elif N_TIME_REVIEWS <= 5: medium
  else: high

L1.5 Phase Analysis:
  WORST_PHASE
  BEST_PHASE
  TIME_PATTERN

============================================================
Formulas & Decision Policy
============================================================

Formulas (extends G3i with L1.5 time pattern bonus):
  EFFICIENCY_RATE = N_GOOD / max(N_GOOD + N_BAD, 1)

  POSITIVE_SCORE = N_GOOD * 1.5
  NEGATIVE_SCORE = N_BAD * 1.5

  # L1.5 Time Pattern Bonus (NEW in G3j)
  TIME_PATTERN_BONUS:
    if TIME_PATTERN = "consistently_efficient": +2.0
    elif TIME_PATTERN = "seating_bottleneck": -0.5
    elif TIME_PATTERN = "kitchen_slow": -1.0
    elif TIME_PATTERN = "checkout_issues": -0.5
    elif TIME_PATTERN = "phase_dependent": 0.0
    else: -1.5

  RAW_SCORE = BASE_SCORE + POSITIVE_SCORE - NEGATIVE_SCORE + TIME_PATTERN_BONUS
  FINAL_SCORE = clamp(RAW_SCORE, 0.0, 10.0)

Decision Thresholds on FINAL_SCORE:
  - >= 7.5 => Excellent Timing
  - >= 5.5 AND < 7.5 => Good Timing
  - >= 3.5 AND < 5.5 => Variable Timing
  - < 3.5 => Poor Timing

Overrides:
  - If TIME_PATTERN = "consistently_efficient" => min Good Timing
  - If TIME_PATTERN = "seating_bottleneck" => include reservation tip
  - If TIME_PATTERN = "overall_slow" AND N_BAD >= 3 => Poor Timing
  - Include phase-specific advice based on WORST_PHASE

============================================================
Output Schema
============================================================

{
  L0_primitives: [ ... one record per time-related review ... ],
  L1_composites: [ ... one record per time-related review ... ],
  L1_5_phase_buckets: {
    arrival: { n_reviews, n_good, n_bad, efficiency_rate },
    during_meal: { n_reviews, n_good, n_bad, efficiency_rate },
    departure: { n_reviews, n_good, n_bad, efficiency_rate },
    worst_phase,
    best_phase,
    n_phases_efficient,
    time_pattern
  },
  L2_aggregates: {
    N_TIME_REVIEWS,
    CONFIDENCE_LEVEL,
    N_GOOD, N_BAD,
    EFFICIENCY_RATE,
    POSITIVE_SCORE,
    NEGATIVE_SCORE,
    BASE_SCORE,
    RAW_SCORE,
    FINAL_SCORE
  },
  DecisionPolicy: {
    base_verdict_by_score,
    override_applied,
    VERDICT,
    phase_advice (if applicable)
  },
  decision_evidence: {
    good_timing_mentions: [ {review_id, phase, quote}, ... ],
    bad_timing_mentions: [ {review_id, phase, quote}, ... ],
    phase_evidence: {
      worst_phase,
      time_pattern
    }
  }
}
