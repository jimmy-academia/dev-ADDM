============================================================
Agenda
============================================================

Help assess the price-to-value ratio at this restaurant.

Analyze each review to identify mentions of pricing, portions, and value.
For each record, extract the L0 primitives defined below.

This task adds L1.5 meal-type grouping to identify when value is best.

============================================================
L0: Primitives (per-review extraction)
============================================================

PRICE_LEVEL
- cheap: explicitly noted as inexpensive, budget-friendly
- moderate: reasonable, fair pricing
- expensive: high prices noted
- very_expensive: sticker shock, extremely pricey
- not_mentioned: price not discussed

PORTION_SIZE
- generous: large portions, plenty of food
- adequate: normal, expected portions
- small: portions smaller than expected
- tiny: notably insufficient portions
- not_mentioned: portions not discussed

QUALITY_PERCEPTION
- exceptional: outstanding quality, premium ingredients
- good: quality meets expectations
- average: nothing special, adequate
- poor: quality below expectations
- not_mentioned: quality not discussed

VALUE_SENTIMENT
- excellent_value: explicitly praised value for money
- good_value: worth the price
- fair: acceptable value
- poor_value: not worth the price
- ripoff: felt cheated or overcharged
- not_mentioned: value not discussed

MEAL_TYPE
- lunch: lunch service
- dinner: dinner service
- brunch: brunch or breakfast
- drinks_only: bar, drinks, appetizers
- not_specified: meal type not mentioned

WOULD_RETURN_FOR_VALUE
- yes: would return based on value
- maybe: uncertain about returning
- no: would not return due to value concerns
- not_mentioned: not discussed

============================================================
L1: Composites (derived per review)
============================================================

POSITIVE_VALUE = true iff ANY:
  - VALUE_SENTIMENT in {excellent_value, good_value}
  - (PRICE_LEVEL in {cheap, moderate} AND QUALITY_PERCEPTION in {exceptional, good})
  - (PORTION_SIZE = generous AND PRICE_LEVEL != very_expensive)
Else POSITIVE_VALUE = false

NEGATIVE_VALUE = true iff ANY:
  - VALUE_SENTIMENT in {poor_value, ripoff}
  - (PRICE_LEVEL in {expensive, very_expensive} AND QUALITY_PERCEPTION in {average, poor})
  - (PORTION_SIZE in {small, tiny} AND PRICE_LEVEL in {expensive, very_expensive})
Else NEGATIVE_VALUE = false

============================================================
L1.5: Meal Type Grouping
============================================================

Group reviews by MEAL_TYPE:
  LUNCH = lunch (often better value, smaller menu)
  DINNER = dinner (typically higher prices)
  CASUAL = brunch, drinks_only (variable pricing)

For each meal bucket, compute:
  BUCKET_N_REVIEWS = count of reviews in this bucket
  BUCKET_N_POSITIVE = count where POSITIVE_VALUE = true
  BUCKET_N_NEGATIVE = count where NEGATIVE_VALUE = true
  BUCKET_VALUE_RATE = BUCKET_N_POSITIVE / max(BUCKET_N_POSITIVE + BUCKET_N_NEGATIVE, 1)

Meal Value Pattern Analysis:
  BEST_VALUE_MEAL = bucket with highest VALUE_RATE (if any data)
  WORST_VALUE_MEAL = bucket with lowest VALUE_RATE (if any data)
  N_MEALS_GOOD_VALUE = count of buckets where VALUE_RATE >= 0.7

  VALUE_PATTERN:
    if N_MEALS_GOOD_VALUE >= 3: "consistently_good_value"
    elif LUNCH bucket VALUE_RATE >= 0.8: "lunch_special_value"
    elif DINNER bucket VALUE_RATE >= 0.8: "dinner_worth_splurge"
    elif CASUAL bucket VALUE_RATE >= 0.8: "great_for_casual"
    elif N_MEALS_GOOD_VALUE >= 1: "meal_dependent"
    else: "poor_value_overall"

============================================================
L2: Aggregates (restaurant-level)
============================================================

Constants:
  BASE_SCORE = 5.0

Counts:
  N_VALUE_REVIEWS = count of reviews with any value-related primitives mentioned
  N_POSITIVE = count where POSITIVE_VALUE = true
  N_NEGATIVE = count where NEGATIVE_VALUE = true

Confidence Level:
  if N_VALUE_REVIEWS == 0: none
  elif N_VALUE_REVIEWS <= 2: low
  elif N_VALUE_REVIEWS <= 5: medium
  else: high

L1.5 Meal Analysis:
  BEST_VALUE_MEAL
  BEST_VALUE_RATE
  VALUE_PATTERN

============================================================
Formulas & Decision Policy
============================================================

Formulas (extends G3a with L1.5 value pattern bonus):
  VALUE_RATE = N_POSITIVE / max(N_POSITIVE + N_NEGATIVE, 1)

  POSITIVE_SCORE = N_POSITIVE * 1.5
  NEGATIVE_SCORE = N_NEGATIVE * 1.5

  # L1.5 Value Pattern Bonus (NEW in G3b)
  VALUE_PATTERN_BONUS:
    if VALUE_PATTERN = "consistently_good_value": +2.0
    elif VALUE_PATTERN = "lunch_special_value": +1.0
    elif VALUE_PATTERN = "dinner_worth_splurge": +1.5
    elif VALUE_PATTERN = "great_for_casual": +1.0
    elif VALUE_PATTERN = "meal_dependent": 0.0
    else: -1.0

  RAW_SCORE = BASE_SCORE + POSITIVE_SCORE - NEGATIVE_SCORE + VALUE_PATTERN_BONUS
  FINAL_SCORE = clamp(RAW_SCORE, 0.0, 10.0)

Decision Thresholds on FINAL_SCORE:
  - >= 7.5 => Excellent Value
  - >= 5.5 AND < 7.5 => Good Value
  - >= 3.5 AND < 5.5 => Mixed Value
  - < 3.5 => Poor Value

Overrides:
  - If VALUE_PATTERN = "consistently_good_value" => min Good Value
  - If VALUE_PATTERN = "lunch_special_value" => include lunch recommendation
  - If VALUE_PATTERN = "poor_value_overall" AND N_NEGATIVE >= 3 => Poor Value
  - If any bucket has VALUE_RATE >= 0.9 AND N_REVIEWS >= 3 => note best value time

============================================================
Output Schema
============================================================

{
  L0_primitives: [ ... one record per value-related review ... ],
  L1_composites: [ ... one record per value-related review ... ],
  L1_5_meal_buckets: {
    lunch: { n_reviews, n_positive, n_negative, value_rate },
    dinner: { n_reviews, n_positive, n_negative, value_rate },
    casual: { n_reviews, n_positive, n_negative, value_rate },
    best_value_meal,
    best_value_rate,
    worst_value_meal,
    n_meals_good_value,
    value_pattern
  },
  L2_aggregates: {
    N_VALUE_REVIEWS,
    CONFIDENCE_LEVEL,
    N_POSITIVE, N_NEGATIVE,
    VALUE_RATE,
    POSITIVE_SCORE,
    NEGATIVE_SCORE,
    BASE_SCORE,
    RAW_SCORE,
    FINAL_SCORE
  },
  DecisionPolicy: {
    base_verdict_by_score,
    override_applied,
    VERDICT,
    meal_recommendation (if applicable)
  },
  decision_evidence: {
    positive_value_mentions: [ {review_id, meal_type, quote}, ... ],
    negative_value_mentions: [ {review_id, meal_type, quote}, ... ],
    meal_evidence: {
      best_value_meal,
      value_pattern
    }
  }
}
