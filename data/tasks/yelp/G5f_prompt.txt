============================================================
Agenda
============================================================

Help assess the restaurant's order execution accuracy and handling.

Analyze each review to identify mentions of order accuracy, special requests, and error handling.
For each record, extract the L0 primitives defined below.

This task adds L1.5 error-type grouping to identify execution patterns.

============================================================
L0: Primitives (per-review extraction)
============================================================

ORDER_ACCURACY
- perfect: order exactly as requested
- correct: order was correct
- minor_error: small mistake (wrong side, missing condiment)
- major_error: significant mistake (wrong dish, missing item)
- completely_wrong: order totally incorrect
- not_mentioned: accuracy not discussed

SPECIAL_REQUEST_HANDLING
- exceeded: went above and beyond for request
- honored: request was accommodated
- partial: request partially fulfilled
- ignored: request was ignored
- refused: request was refused without reason
- not_mentioned: special requests not discussed

TIMING_COORDINATION
- perfectly_timed: all dishes arrived together as expected
- well_coordinated: good timing between courses
- acceptable: timing was fine
- poorly_timed: dishes arrived at wrong times
- chaotic: completely uncoordinated
- not_mentioned: timing not discussed

COMMUNICATION_CLARITY
- excellent: clear communication throughout
- good: adequate communication
- unclear: confusing or unclear communication
- poor: significant communication issues
- not_mentioned: communication not discussed

ERROR_RECOVERY
- excellent: error fixed quickly and professionally
- good: error addressed satisfactorily
- slow: error fixed but took too long
- poor: error handling was inadequate
- none: error not acknowledged
- not_applicable: no errors occurred

============================================================
L1: Composites (derived per review)
============================================================

POSITIVE_EXECUTION = true iff ANY:
  - ORDER_ACCURACY in {perfect, correct}
  - SPECIAL_REQUEST_HANDLING in {exceeded, honored}
  - TIMING_COORDINATION in {perfectly_timed, well_coordinated}
Else POSITIVE_EXECUTION = false

NEGATIVE_EXECUTION = true iff ANY:
  - ORDER_ACCURACY in {major_error, completely_wrong}
  - SPECIAL_REQUEST_HANDLING in {ignored, refused}
  - TIMING_COORDINATION in {poorly_timed, chaotic}
Else NEGATIVE_EXECUTION = false

============================================================
L1.5: Error Type Grouping
============================================================

Group reviews by error type:
  ORDER_ERRORS = order_accuracy issues (minor_error, major_error, completely_wrong)
  TIMING_ERRORS = timing_coordination issues (poorly_timed, chaotic)
  COMMUNICATION_ERRORS = communication and special request issues

For each error bucket, compute:
  BUCKET_N_REVIEWS = count of reviews with this error type
  BUCKET_N_RESOLVED = count where error was recovered (ERROR_RECOVERY in {excellent, good})
  BUCKET_N_UNRESOLVED = count where error was not recovered
  BUCKET_RESOLUTION_RATE = BUCKET_N_RESOLVED / max(BUCKET_N_REVIEWS, 1)

Execution Pattern Analysis:
  WORST_ERROR_TYPE = bucket with most unresolved errors
  BEST_RESOLUTION = bucket with highest RESOLUTION_RATE
  N_ERROR_TYPES_PROBLEMATIC = count of buckets where RESOLUTION_RATE < 0.5

  EXECUTION_PATTERN:
    if N_ERROR_TYPES_PROBLEMATIC == 0 AND total errors < 2: "execution_excellence"
    elif ORDER_ERRORS RESOLUTION_RATE >= 0.8: "recovers_well"
    elif TIMING_ERRORS N_REVIEWS > 3: "timing_challenged"
    elif COMMUNICATION_ERRORS N_REVIEWS > 3: "communication_gaps"
    elif N_ERROR_TYPES_PROBLEMATIC >= 2: "systemic_issues"
    elif N_ERROR_TYPES_PROBLEMATIC == 1: "isolated_weakness"
    else: "needs_improvement"

============================================================
L2: Aggregates (restaurant-level)
============================================================

Constants:
  BASE_SCORE = 5.0

Counts:
  N_EXECUTION_REVIEWS = count of reviews with any execution-related primitives
  N_POSITIVE = count where POSITIVE_EXECUTION = true
  N_NEGATIVE = count where NEGATIVE_EXECUTION = true

Confidence Level:
  if N_EXECUTION_REVIEWS == 0: none
  elif N_EXECUTION_REVIEWS <= 2: low
  elif N_EXECUTION_REVIEWS <= 5: medium
  else: high

L1.5 Error Analysis:
  WORST_ERROR_TYPE
  BEST_RESOLUTION
  EXECUTION_PATTERN

============================================================
Formulas & Decision Policy
============================================================

Formulas:
  SATISFACTION_RATE = N_POSITIVE / max(N_POSITIVE + N_NEGATIVE, 1)

  POSITIVE_SCORE = N_POSITIVE * 1.5
  NEGATIVE_SCORE = N_NEGATIVE * 1.5

  RAW_SCORE = BASE_SCORE + POSITIVE_SCORE - NEGATIVE_SCORE
  FINAL_SCORE = clamp(RAW_SCORE, 0.0, 10.0)

Decision Thresholds on FINAL_SCORE:
  - >= 7.5 => Excellent Execution
  - >= 5.5 AND < 7.5 => Good Execution
  - >= 3.5 AND < 5.5 => Average Execution
  - < 3.5 => Poor Execution

Overrides:
  - If EXECUTION_PATTERN = "execution_excellence" => min Good Execution
  - If EXECUTION_PATTERN = "systemic_issues" => max Average Execution
  - Include strength note based on EXECUTION_PATTERN
  - Include improvement note based on WORST_ERROR_TYPE

============================================================
Output Schema
============================================================

{
  L0_primitives: [ ... one record per execution-related review ... ],
  L1_composites: [ ... one record per execution-related review ... ],
  L1_5_error_buckets: {
    order_errors: { n_reviews, n_resolved, n_unresolved, resolution_rate },
    timing_errors: { n_reviews, n_resolved, n_unresolved, resolution_rate },
    communication_errors: { n_reviews, n_resolved, n_unresolved, resolution_rate },
    worst_error_type,
    best_resolution,
    n_error_types_problematic,
    execution_pattern
  },
  L2_aggregates: {
    N_EXECUTION_REVIEWS,
    CONFIDENCE_LEVEL,
    N_POSITIVE, N_NEGATIVE,
    SATISFACTION_RATE,
    POSITIVE_SCORE,
    NEGATIVE_SCORE,
    BASE_SCORE,
    RAW_SCORE,
    FINAL_SCORE
  },
  DecisionPolicy: {
    base_verdict_by_score,
    override_applied,
    VERDICT,
    strength_note (if applicable),
    improvement_note (if applicable)
  },
  decision_evidence: {
    positive_execution_mentions: [ {review_id, error_type, quote}, ... ],
    negative_execution_mentions: [ {review_id, error_type, quote}, ... ],
    error_evidence: {
      worst_error_type,
      best_resolution,
      execution_pattern
    }
  }
}
