============================================================
Agenda
============================================================

Help assess the restaurant's order execution accuracy and handling.

Analyze each review to identify mentions of order accuracy, special requests, and error handling.
For each record, extract the L0 primitives defined below.

This task combines complex formula (weighted factors, interactions)
with L1.5 error-type grouping for pattern detection.

============================================================
L0: Primitives (per-review extraction)
============================================================

ORDER_ACCURACY
- perfect: order exactly as requested
- correct: order was correct
- minor_error: small mistake (wrong side, missing condiment)
- major_error: significant mistake (wrong dish, missing item)
- completely_wrong: order totally incorrect
- not_mentioned: accuracy not discussed

SPECIAL_REQUEST_HANDLING
- exceeded: went above and beyond for request
- honored: request was accommodated
- partial: request partially fulfilled
- ignored: request was ignored
- refused: request was refused without reason
- not_mentioned: special requests not discussed

TIMING_COORDINATION
- perfectly_timed: all dishes arrived together as expected
- well_coordinated: good timing between courses
- acceptable: timing was fine
- poorly_timed: dishes arrived at wrong times
- chaotic: completely uncoordinated
- not_mentioned: timing not discussed

COMMUNICATION_CLARITY
- excellent: clear communication throughout
- good: adequate communication
- unclear: confusing or unclear communication
- poor: significant communication issues
- not_mentioned: communication not discussed

ERROR_RECOVERY
- excellent: error fixed quickly and professionally
- good: error addressed satisfactorily
- slow: error fixed but took too long
- poor: error handling was inadequate
- none: error not acknowledged
- not_applicable: no errors occurred

============================================================
L1: Composites (derived per review) - COMPLEX
============================================================

Accuracy Score:
  perfect = +4.0
  correct = +2.0
  minor_error = -0.5
  major_error = -3.0
  completely_wrong = -5.0
  not_mentioned = 0

Request Score:
  exceeded = +3.0
  honored = +1.5
  partial = -0.5
  ignored = -2.5
  refused = -3.0
  not_mentioned = 0

Timing Score:
  perfectly_timed = +2.5
  well_coordinated = +1.5
  acceptable = 0
  poorly_timed = -2.0
  chaotic = -4.0
  not_mentioned = 0

Communication Score:
  excellent = +2.0
  good = +1.0
  unclear = -1.0
  poor = -2.5
  not_mentioned = 0

Recovery Score:
  excellent = +2.5
  good = +1.5
  slow = 0
  poor = -2.0
  none = -3.0
  not_applicable = 0

L1_EXECUTION_SCORE = ACCURACY_SCORE + REQUEST_SCORE + TIMING_SCORE + COMMUNICATION_SCORE + RECOVERY_SCORE

COMPLETE_FAILURE_PENALTY:
  If ORDER_ACCURACY = completely_wrong AND ERROR_RECOVERY in {poor, none}: -3.0
  Else: 0

L1_TOTAL_SCORE = L1_EXECUTION_SCORE + COMPLETE_FAILURE_PENALTY

============================================================
L1.5: Error Type Grouping
============================================================

Group reviews by error type:
  ORDER_ERRORS = order_accuracy issues (accuracy_score < 0)
  TIMING_ERRORS = timing_coordination issues (timing_score < 0)
  COMMUNICATION_ERRORS = communication and request issues (communication_score < 0 OR request_score < 0)

For each error bucket, compute:
  BUCKET_N_REVIEWS = count of reviews with this error type
  BUCKET_SUM_SCORE = sum of relevant error scores in bucket
  BUCKET_MEAN_SCORE = BUCKET_SUM_SCORE / max(BUCKET_N_REVIEWS, 1)
  BUCKET_N_RECOVERED = count where ERROR_RECOVERY in {excellent, good}
  BUCKET_RECOVERY_RATE = BUCKET_N_RECOVERED / max(BUCKET_N_REVIEWS, 1)

Execution Pattern Analysis:
  WORST_ERROR_TYPE = bucket with lowest MEAN_SCORE
  WORST_ERROR_SCORE = MEAN_SCORE of WORST_ERROR_TYPE
  BEST_RECOVERY_TYPE = bucket with highest RECOVERY_RATE
  N_ERROR_TYPES_SEVERE = count of buckets where MEAN_SCORE < -2.0

  EXECUTION_PATTERN:
    if N_ERROR_TYPES_SEVERE == 0 AND total BUCKET_N_REVIEWS < 2: "precision_execution"
    elif ORDER_ERRORS RECOVERY_RATE >= 0.8 AND ORDER_ERRORS N_REVIEWS > 0: "resilient_recovery"
    elif TIMING_ERRORS MEAN_SCORE < -2.5: "timing_breakdown"
    elif COMMUNICATION_ERRORS MEAN_SCORE < -2.0: "communication_failure"
    elif N_ERROR_TYPES_SEVERE >= 2: "multi_point_failure"
    elif WORST_ERROR_SCORE < -3.0: "critical_weakness"
    else: "execution_gaps"

============================================================
L2: Aggregates (restaurant-level)
============================================================

Constants:
  BASE_SCORE = 5.0

Counts:
  N_EXECUTION_REVIEWS = count of reviews with any execution-related primitives
  N_MAJOR_ERROR = count where ORDER_ACCURACY in {major_error, completely_wrong}
  N_POOR_RECOVERY = count where ERROR_RECOVERY in {poor, none}

Confidence Level:
  if N_EXECUTION_REVIEWS == 0: none
  elif N_EXECUTION_REVIEWS <= 2: low
  elif N_EXECUTION_REVIEWS <= 5: medium
  else: high

L1.5 Error Aggregation:
  TOTAL_ERROR_SCORE = sum of BUCKET_MEAN_SCORE across all error buckets with data
  N_ERROR_BUCKETS_ACTIVE = count of buckets where N_REVIEWS > 0
  MEAN_ERROR_SCORE = TOTAL_ERROR_SCORE / max(N_ERROR_BUCKETS_ACTIVE, 1)

============================================================
Formulas & Decision Policy
============================================================

Formulas:
  Pattern Multiplier (based on execution pattern):
    if EXECUTION_PATTERN = "precision_execution": PATTERN_MULT = 1.2
    elif EXECUTION_PATTERN = "resilient_recovery": PATTERN_MULT = 1.1
    elif EXECUTION_PATTERN in {"timing_breakdown", "communication_failure"}: PATTERN_MULT = 0.9
    elif EXECUTION_PATTERN = "multi_point_failure": PATTERN_MULT = 0.75
    else: PATTERN_MULT = 1.0

  # Use L1 mean if no errors, otherwise factor in error analysis
  if N_ERROR_BUCKETS_ACTIVE == 0:
    SUM_L1_SCORE = sum of L1_TOTAL_SCORE across all execution reviews
    MEAN_L1_SCORE = SUM_L1_SCORE / max(N_EXECUTION_REVIEWS, 1)
    ADJUSTED_SCORE = MEAN_L1_SCORE * PATTERN_MULT
  else:
    ADJUSTED_SCORE = MEAN_ERROR_SCORE * PATTERN_MULT

  RAW_SCORE = BASE_SCORE + ADJUSTED_SCORE
  FINAL_SCORE = clamp(RAW_SCORE, 0.0, 10.0)

Decision Thresholds on FINAL_SCORE:
  - >= 7.5 => Excellent Execution
  - >= 5.5 AND < 7.5 => Good Execution
  - >= 3.5 AND < 5.5 => Average Execution
  - < 3.5 => Poor Execution

Overrides:
  - If N_MAJOR_ERROR >= 2 => max Average Execution
  - If EXECUTION_PATTERN = "precision_execution" => min Good Execution
  - If EXECUTION_PATTERN = "multi_point_failure" => max Average Execution
  - Include strength note based on BEST_RECOVERY_TYPE if RECOVERY_RATE >= 0.7
  - Include improvement note based on WORST_ERROR_TYPE

============================================================
Output Schema
============================================================

{
  L0_primitives: [ ... one record per execution-related review ... ],
  L1_composites: [
    {
      review_id,
      accuracy_score,
      request_score,
      timing_score,
      communication_score,
      recovery_score,
      l1_execution_score,
      complete_failure_penalty,
      l1_total_score
    },
    ...
  ],
  L1_5_error_buckets: {
    order_errors: { n_reviews, sum_score, mean_score, n_recovered, recovery_rate },
    timing_errors: { n_reviews, sum_score, mean_score, n_recovered, recovery_rate },
    communication_errors: { n_reviews, sum_score, mean_score, n_recovered, recovery_rate },
    worst_error_type,
    worst_error_score,
    best_recovery_type,
    n_error_types_severe,
    execution_pattern
  },
  L2_aggregates: {
    N_EXECUTION_REVIEWS,
    CONFIDENCE_LEVEL,
    N_MAJOR_ERROR, N_POOR_RECOVERY,
    TOTAL_ERROR_SCORE,
    MEAN_ERROR_SCORE,
    PATTERN_MULT,
    BASE_SCORE,
    ADJUSTED_SCORE,
    RAW_SCORE,
    FINAL_SCORE
  },
  DecisionPolicy: {
    base_verdict_by_score,
    override_applied,
    VERDICT,
    strength_note (if applicable),
    improvement_note (if applicable)
  },
  decision_evidence: {
    high_score_reviews: [ {review_id, error_type, l1_total_score, quote}, ... ],
    low_score_reviews: [ {review_id, error_type, l1_total_score, quote}, ... ],
    error_evidence: {
      worst_error_type,
      best_recovery_type,
      execution_pattern
    }
  }
}
